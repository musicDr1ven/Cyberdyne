{"ts":1401248684138,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"//CLIENT\n\n// Fallbacks for vendor-specific variables until the spec is finalized.\n\nvar PeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);\nvar URL = (window.URL || window.webkitURL || window.msURL || window.oURL);\nvar getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);\nvar nativeRTCIceCandidate = (window.mozRTCIceCandidate || window.RTCIceCandidate);\nvar nativeRTCSessionDescription = (window.mozRTCSessionDescription || window.RTCSessionDescription); // order is very important: \"RTCSessionDescription\" defined in Nighly but useless\n\nvar sdpConstraints = {\n  'mandatory': {\n    'OfferToReceiveAudio': true,\n    'OfferToReceiveVideo': true\n  }\n};\n\nif (navigator.webkitGetUserMedia) {\n  if (!webkitMediaStream.prototype.getVideoTracks) {\n    webkitMediaStream.prototype.getVideoTracks = function() {\n      return this.videoTracks;\n    };\n    webkitMediaStream.prototype.getAudioTracks = function() {\n      return this.audioTracks;\n    };\n  }\n\n  // New syntax of getXXXStreams method in M26.\n  if (!webkitRTCPeerConnection.prototype.getLocalStreams) {\n    webkitRTCPeerConnection.prototype.getLocalStreams = function() {\n      return this.localStreams;\n    };\n    webkitRTCPeerConnection.prototype.getRemoteStreams = function() {\n      return this.remoteStreams;\n    };\n  }\n}\n\n(function() {\n\n  var rtc;\n  if ('undefined' === typeof module) {\n    rtc = this.rtc = {};\n  } else {\n    rtc = module.exports = {};\n  }\n\n\n  // Holds a connection to the server.\n  rtc._socket = null;\n\n  // Holds identity for the client\n  rtc._me = null;\n\n  // Holds callbacks for certain events.\n  rtc._events = {};\n\n  rtc.on = function(eventName, callback) {\n    rtc._events[eventName] = rtc._events[eventName] || [];\n    rtc._events[eventName].push(callback);\n  };\n\n  rtc.fire = function(eventName, _) {\n    var events = rtc._events[eventName];\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if (!events) {\n      return;\n    }\n\n    for (var i = 0, len = events.length; i < len; i++) {\n      events[i].apply(null, args);\n    }\n  };\n\n  // Holds the STUN/ICE server to use for PeerConnections.\n  rtc.SERVER = function() {\n    if (navigator.mozGetUserMedia) {\n      return {\n        \"iceServers\": [{\n          \"url\": \"stun:23.21.150.121\"\n        }]\n      };\n    }\n    return {\n      \"iceServers\": [{\n        \"url\": \"stun:stun.l.google.com:19302\"\n      }]\n    };\n  };\n\n\n  // Reference to the lone PeerConnection instance.\n  rtc.peerConnections = {};\n\n  // Array of known peer socket ids\n  rtc.connections = [];\n  // Stream-related variables.\n  rtc.streams = [];\n  rtc.numStreams = 0;\n  rtc.initializedStreams = 0;\n\n\n  // Reference to the data channels\n  rtc.dataChannels = {};\n\n  // PeerConnection datachannel configuration\n  rtc.dataChannelConfig = {\n    \"optional\": [{\n      \"RtpDataChannels\": true\n    }, {\n      \"DtlsSrtpKeyAgreement\": true\n    }]\n  };\n\n  rtc.pc_constraints = {\n    \"optional\": [{\n      \"DtlsSrtpKeyAgreement\": true\n    }]\n  };\n\n\n  // check whether data channel is supported.\n  rtc.checkDataChannelSupport = function() {\n    try {\n      // raises exception if createDataChannel is not supported\n      var pc = new PeerConnection(rtc.SERVER(), rtc.dataChannelConfig);\n      var channel = pc.createDataChannel('supportCheck', {\n        reliable: false\n      });\n      channel.close();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  rtc.dataChannelSupport = rtc.checkDataChannelSupport();\n\n\n  /**\n   * Connects to the websocket server.\n   */\n  rtc.connect = function(server, room) {\n    room = room || \"\"; // by default, join a room called the blank string\n    rtc._socket = new WebSocket(server);\n\n    rtc._socket.onopen = function() {\n\n      rtc._socket.send(JSON.stringify({\n        \"eventName\": \"join_room\",\n        \"data\": {\n          \"room\": room\n        }\n      }));\n\n      rtc._socket.onmessage = function(msg) {\n        var json = JSON.parse(msg.data);\n        rtc.fire(json.eventName, json.data);\n      };\n\n      rtc._socket.onerror = function(err) {\n        console.error('onerror');\n        console.error(err);\n      };\n\n      rtc._socket.onclose = function(data) {\n        rtc.fire('disconnect stream', rtc._socket.id);\n        delete rtc.peerConnections[rtc._socket.id];\n      };\n\n      rtc.on('get_peers', function(data) {\n        rtc.connections = data.connections;\n        rtc._me = data.you;\n        // fire connections event and pass peers\n        rtc.fire('connections', rtc.connections);\n      });\n\n      rtc.on('receive_ice_candidate', function(data) {\n        var candidate = new nativeRTCIceCandidate(data);\n        rtc.peerConnections[data.socketId].addIceCandidate(candidate);\n        rtc.fire('receive ice candidate', candidate);\n      });\n\n      rtc.on('new_peer_connected', function(data) {\n        rtc.connections.push(data.socketId);\n\n        var pc = rtc.createPeerConnection(data.socketId);\n        for (var i = 0; i < rtc.streams.length; i++) {\n          var stream = rtc.streams[i];\n          pc.addStream(stream);\n        }\n      });\n\n      rtc.on('remove_peer_connected', function(data) {\n        rtc.fire('disconnect stream', data.socketId);\n        delete rtc.peerConnections[data.socketId];\n      });\n\n      rtc.on('receive_offer', function(data) {\n        rtc.receiveOffer(data.socketId, data.sdp);\n        rtc.fire('receive offer', data);\n      });\n\n      rtc.on('receive_answer', function(data) {\n        rtc.receiveAnswer(data.socketId, data.sdp);\n        rtc.fire('receive answer', data);\n      });\n\n      rtc.fire('connect');\n    };\n  };\n\n\n  rtc.sendOffers = function() {\n    for (var i = 0, len = rtc.connections.length; i < len; i++) {\n      var socketId = rtc.connections[i];\n      rtc.sendOffer(socketId);\n    }\n  };\n\n  rtc.onClose = function(data) {\n    rtc.on('close_stream', function() {\n      rtc.fire('close_stream', data);\n    });\n  };\n\n  rtc.createPeerConnections = function() {\n    for (var i = 0; i < rtc.connections.length; i++) {\n      rtc.createPeerConnection(rtc.connections[i]);\n    }\n  };\n\n  rtc.createPeerConnection = function(id) {\n\n    var config = rtc.pc_constraints;\n    if (rtc.dataChannelSupport) config = rtc.dataChannelConfig;\n\n    var pc = rtc.peerConnections[id] = new PeerConnection(rtc.SERVER(), config);\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        rtc._socket.send(JSON.stringify({\n          \"eventName\": \"send_ice_candidate\",\n          \"data\": {\n            \"label\": event.candidate.sdpMLineIndex,\n            \"candidate\": event.candidate.candidate,\n            \"socketId\": id\n          }\n        }));\n      }\n      rtc.fire('ice candidate', event.candidate);\n    };\n\n    pc.onopen = function() {\n      // TODO: Finalize this API\n      rtc.fire('peer connection opened');\n    };\n\n    pc.onaddstream = function(event) {\n      // TODO: Finalize this API\n      rtc.fire('add remote stream', event.stream, id);\n    };\n\n    if (rtc.dataChannelSupport) {\n      pc.ondatachannel = function(evt) {\n        console.log('data channel connecting ' + id);\n        rtc.addDataChannel(id, evt.channel);\n      };\n    }\n\n    return pc;\n  };\n\n  rtc.sendOffer = function(socketId) {\n    var pc = rtc.peerConnections[socketId];\n\n    var constraints = {\n      \"optional\": [],\n      \"mandatory\": {\n        \"MozDontOfferDataChannel\": true\n      }\n    };\n    // temporary measure to remove Moz* constraints in Chrome\n    if (navigator.webkitGetUserMedia) {\n      for (var prop in constraints.mandatory) {\n        if (prop.indexOf(\"Moz\") != -1) {\n          delete constraints.mandatory[prop];\n        }\n      }\n    }\n    constraints = mergeConstraints(constraints, sdpConstraints);\n\n    pc.createOffer(function(session_description) {\n      session_description.sdp = preferOpus(session_description.sdp);\n      pc.setLocalDescription(session_description);\n      rtc._socket.send(JSON.stringify({\n        \"eventName\": \"send_offer\",\n        \"data\": {\n          \"socketId\": socketId,\n          \"sdp\": session_description\n        }\n      }));\n    }, null, sdpConstraints);\n  };\n\n  rtc.receiveOffer = function(socketId, sdp) {\n    var pc = rtc.peerConnections[socketId];\n    rtc.sendAnswer(socketId, sdp);\n  };\n\n  rtc.sendAnswer = function(socketId, sdp) {\n    var pc = rtc.peerConnections[socketId];\n    pc.setRemoteDescription(new nativeRTCSessionDescription(sdp));\n    pc.createAnswer(function(session_description) {\n      pc.setLocalDescription(session_description);\n      rtc._socket.send(JSON.stringify({\n        \"eventName\": \"send_answer\",\n        \"data\": {\n          \"socketId\": socketId,\n          \"sdp\": session_description\n        }\n      }));\n      //TODO Unused variable!?\n      var offer = pc.remoteDescription;\n    }, null, sdpConstraints);\n  };\n\n\n  rtc.receiveAnswer = function(socketId, sdp) {\n    var pc = rtc.peerConnections[socketId];\n    pc.setRemoteDescription(new nativeRTCSessionDescription(sdp));\n  };\n\n\n  rtc.createStream = function(opt, onSuccess, onFail) {\n    var options;\n    onSuccess = onSuccess || function() {};\n    onFail = onFail || function() {};\n\n    options = {\n      video: !! opt.video,\n      audio: !! opt.audio\n    };\n\n    if (getUserMedia) {\n      rtc.numStreams++;\n      getUserMedia.call(navigator, options, function(stream) {\n\n        rtc.streams.push(stream);\n        rtc.initializedStreams++;\n        onSuccess(stream);\n        if (rtc.initializedStreams === rtc.numStreams) {\n          rtc.fire('ready');\n        }\n      }, function() {\n        alert(\"Could not connect stream.\");\n        onFail();\n      });\n    } else {\n      alert('webRTC is not yet supported in this browser.');\n    }\n  };\n\n  rtc.addStreams = function() {\n    for (var i = 0; i < rtc.streams.length; i++) {\n      var stream = rtc.streams[i];\n      for (var connection in rtc.peerConnections) {\n        rtc.peerConnections[connection].addStream(stream);\n      }\n    }\n  };\n\n  rtc.attachStream = function(stream, domId) {\n    var element = document.getElementById(domId);\n    if (navigator.mozGetUserMedia) {\n      console.log(\"Attaching media stream\");\n      element.mozSrcObject = stream;\n      element.play();\n    } else {\n      element.src = webkitURL.createObjectURL(stream);\n    }\n  };\n\n\n  rtc.createDataChannel = function(pcOrId, label) {\n    if (!rtc.dataChannelSupport) {\n      //TODO this should be an exception\n      alert('webRTC data channel is not yet supported in this browser,' +\n        ' or you must turn on experimental flags');\n      return;\n    }\n\n    var id, pc;\n    if (typeof(pcOrId) === 'string') {\n      id = pcOrId;\n      pc = rtc.peerConnections[pcOrId];\n    } else {\n      pc = pcOrId;\n      id = undefined;\n      for (var key in rtc.peerConnections) {\n        if (rtc.peerConnections[key] === pc) id = key;\n      }\n    }\n\n    if (!id) throw new Error('attempt to createDataChannel with unknown id');\n\n    if (!pc || !(pc instanceof PeerConnection)) throw new Error('attempt to createDataChannel without peerConnection');\n\n    // need a label\n    label = label || 'fileTransfer' || String(id);\n\n    // chrome only supports reliable false atm.\n    var options = {\n      reliable: false\n    };\n\n    var channel;\n    try {\n      console.log('createDataChannel ' + id);\n      channel = pc.createDataChannel(label, options);\n    } catch (error) {\n      console.log('seems that DataChannel is NOT actually supported!');\n      throw error;\n    }\n\n    return rtc.addDataChannel(id, channel);\n  };\n\n  rtc.addDataChannel = function(id, channel) {\n\n    channel.onopen = function() {\n      console.log('data stream open ' + id);\n      rtc.fire('data stream open', channel);\n    };\n\n    channel.onclose = function(event) {\n      delete rtc.dataChannels[id];\n      console.log('data stream close ' + id);\n      rtc.fire('data stream close', channel);\n    };\n\n    channel.onmessage = function(message) {\n      console.log('data stream message ' + id);\n      console.log(message);\n      rtc.fire('data stream data', channel, message.data);\n    };\n\n    channel.onerror = function(err) {\n      console.log('data stream error ' + id + ': ' + err);\n      rtc.fire('data stream error', channel, err);\n    };\n\n    // track dataChannel\n    rtc.dataChannels[id] = channel;\n    return channel;\n  };\n\n  rtc.addDataChannels = function() {\n    if (!rtc.dataChannelSupport) return;\n\n    for (var connection in rtc.peerConnections)\n    rtc.createDataChannel(connection);\n  };\n\n\n  rtc.on('ready', function() {\n    rtc.createPeerConnections();\n    rtc.addStreams();\n    rtc.addDataChannels();\n    rtc.sendOffers();\n  });\n\n}).call(this);\n\nfunction preferOpus(sdp) {\n  var sdpLines = sdp.split('\\r\\n');\n  var mLineIndex = null;\n  // Search for m line.\n  for (var i = 0; i < sdpLines.length; i++) {\n    if (sdpLines[i].search('m=audio') !== -1) {\n      mLineIndex = i;\n      break;\n    }\n  }\n  if (mLineIndex === null) return sdp;\n\n  // If Opus is available, set it as the default in m line.\n  for (var j = 0; j < sdpLines.length; j++) {\n    if (sdpLines[j].search('opus/48000') !== -1) {\n      var opusPayload = extractSdp(sdpLines[j], /:(\\d+) opus\\/48000/i);\n      if (opusPayload) sdpLines[mLineIndex] = setDefaultCodec(sdpLines[mLineIndex], opusPayload);\n      break;\n    }\n  }\n\n  // Remove CN in m line and sdp.\n  sdpLines = removeCN(sdpLines, mLineIndex);\n\n  sdp = sdpLines.join('\\r\\n');\n  return sdp;\n}\n\nfunction extractSdp(sdpLine, pattern) {\n  var result = sdpLine.match(pattern);\n  return (result && result.length == 2) ? result[1] : null;\n}\n\nfunction setDefaultCodec(mLine, payload) {\n  var elements = mLine.split(' ');\n  var newLine = [];\n  var index = 0;\n  for (var i = 0; i < elements.length; i++) {\n    if (index === 3) // Format of media starts from the fourth.\n    newLine[index++] = payload; // Put target payload to the first.\n    if (elements[i] !== payload) newLine[index++] = elements[i];\n  }\n  return newLine.join(' ');\n}\n\nfunction removeCN(sdpLines, mLineIndex) {\n  var mLineElements = sdpLines[mLineIndex].split(' ');\n  // Scan from end for the convenience of removing an item.\n  for (var i = sdpLines.length - 1; i >= 0; i--) {\n    var payload = extractSdp(sdpLines[i], /a=rtpmap:(\\d+) CN\\/\\d+/i);\n    if (payload) {\n      var cnPos = mLineElements.indexOf(payload);\n      if (cnPos !== -1) {\n        // Remove CN payload from m line.\n        mLineElements.splice(cnPos, 1);\n      }\n      // Remove CN line in sdp\n      sdpLines.splice(i, 1);\n    }\n  }\n\n  sdpLines[mLineIndex] = mLineElements.join(' ');\n  return sdpLines;\n}\n\nfunction mergeConstraints(cons1, cons2) {\n  var merged = cons1;\n  for (var name in cons2.mandatory) {\n    merged.mandatory[name] = cons2.mandatory[name];\n  }\n  merged.optional.concat(cons2.optional);\n  return merged;\n}"]],"start1":0,"start2":0,"length1":0,"length2":14763}]],"length":14763}
